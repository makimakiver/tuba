const router = require("express").Router();
const AIaccount = require("../models/AIaccount");
const Authorized = require("../models/Authorized");
const User = require("../models/User");
const Team = require("../models/Team");
const Key = require("../models/Key");




function XorAscii(str, len){
    const key_index = []
    // store the values used in key
    const pass = []
    // store password as an ASCII code
    
    for (let i = 0; i < len; i++) {
        // while the index is less than the length it will convert all of the character into ascii code
        ASCII = str.codePointAt(i);
        // push them into the stack
        pass.push(ASCII);
        // moy not be needed
    }

    while (key_index.length < pass.length){
        const key_additional = Math.floor(Math.random() * 128);
        // generate a key by making list of random numbers from 1 to 127
        key_index.push(key_additional)
    }

    return key_index;
    // return key_index, decrypter;
}

function NaturalXOR(str){
    XORActual = []    
    for (let i = 0; i < str.length; i++) {
        // while the index is less than the length it will convert all of the character into ascii code
        ASCII = str.codePointAt(i);
        // push them into the stack
        XORActual.push(ASCII);
    }
return XORActual
}

function decription(arr, arr2){
{
    const decrypter = []
    for(let z=0; z < arr.length; z++ ) {
        let value = arr[z]^arr2[z];
        // passing the key and random numbers into XOR gate(Vernam cipher)
        decrypter.push(value)
        // store the list of number generated by the VOR gate
    }
    return decrypter
}  
}

function ValueToChar(List){
const hashed_pass = []
for(let z=0; z < List.length; z++ ) {
    
    if(List[z] < 33){
        List[z] = List[z] + 33
     }
    // value less than 33 cannot be converted into ascii character so has to be greater than 32
    hashed_pass.push(List[z])
    // push the password into the stack
}
let stored_password = ""

for (let l=0; l<hashed_pass.length; l++){
    stored_password += String.fromCharCode(hashed_pass[l])
    // convert them into String
}
return stored_password;
// password is not needed as user have already signed in to the account
}

// CRUD concepts
router.post("/creation", async (req, res) => {
    // HTTP post request is used 
        try{
            if (!req.body.AIname || !req.body.userId){
                return res.status(500).json("error as you dont put anything")
            }
            else{
                const newAI = await new AIaccount({
                    userId: req.body.userId,
                    AIname: req.body.AIname,
                    systemPrompt: req.body.systemPrompt,
                    Desc: req.body.desc,
                    ProfilePicture: req.body.ProfilePicture,
                });
                const AI = await newAI.save();
        
                const newAuthorized = new Authorized({
                    users: req.body.userId,
                    AIId: AI._id,
                });            
                const AuthorizedUser = await newAuthorized.save();

                // const newKey = await new Key({
                //     userId: AI._id,
                //     key_code: keycode,
                //     second: decription(keycode, NaturalXOR(req.body.password)),
                //     human: false,
                // });
                // const AIkey = await newKey.save();

                return res.status(200).json(AI)
            }
        } catch(err) {
            return res.status(500).json(err)
        }    
    });   
    
router.post("/login", async (req, res) => {
    // HTTP post request
        try{
            const AI = await AIaccount.findOne({ AIname: req.body.AIname });
            if (!AI){
                return res.status(404).json("cannot find the account.")
            }else{
                // if written emaiil doesnot exist. 404 indicate to "NOT Found"
                const key = await Key.findOne({ userId: AI._id })  
                // taking userId as an input... improvement is needed.      
                const ValidPassword = ValueToChar(decription(key.key_code, NaturalXOR(req.body.password))) === AI.password;
                if (!ValidPassword) {
                    return res.status(400).json("invalid password. ")
                }else{
            // if ValidPassword is not equal to the password request. 400 indicate to Bad request"
                    return res.status(200).json(AI);
                }
            
            }
        } catch(err) {
            return res.status(500).json(err)
        }    
    });
    
// // user update
router.put("/password/:id", async (req, res) => {
    if (req.body.AIId === req.params.id ) {
        try{
            // console.log(test.XorAscii(req.body.password))
            const keycode = XorAscii(req.body.password, (req.body.password).length) 
            const authorized = await Authorized.findOne({ AIId: req.body.AIId })
            const AI = await AIaccount.findById(req.body.AIId)
        //     const { password, ...other } = user._doc;
        //     const auser = await User.findByIdAndUpdate(req.params.id, {
        //         other: req.body,
        //      // set command allows user to change any values in their database
        // });

            const key = await Key.findOneAndUpdate({userId: req.body.AIId}, {
                key_code: keycode,
                second: decription(keycode, NaturalXOR(req.body.password)),
                human: false,
            }); 

            return res.status(200).json("Your password of your soulmate is updated")               
                  
        } catch(err) {
            return res.status(500).json(err)
        }
    } else {
        return res.status(403).json("cannot change others")
    }
});

router.put("/:id", async (req, res) => {
    // HTTP post request
    if (req.body.AIId === req.params.id ) {
        // only if userID is same as theie userID.
        //improvement is required
        try{
            if (!req.body.password){
                const AI = await AIaccount.findByIdAndUpdate(req.params.id, {
                        AIname: req.body.username,
                        Desc: req.body.Desc,
                        ProfilePicture: req.body.ProfilePicture,
                        IsPrivate: req.body.IsPrivate,
                        TeamBased: req.body.TeamBased,
                                            
                    // apart from password user can change any user information as they want
                });
                return res.status(200).json("your AI account is updated. enjoy!") 
            } else {
                return res.status(500).json("you cannot change password of your AI in this section sorry.")
            }             
                  
        } catch(err) {
            return res.status(500).json(err)
        }
    } else {
        return res.status(403).json("cannot change others")
    }
});


router.delete("/:id", async (req, res) => {
    // HTTP post request
    //improvement required 
    if (req.body.AIId === req.params.id ) {
        try{
            const AI = await AIaccount.findByIdAndDelete(req.params.id);
            const key = await Key.findOneAndDelete({userId: req.params.id});
            // when they are deleted, keys will also be deleted.
            res.status(200).json("your account has been deleted.")           
        } catch(err) {
            return res.status(500).json(err)
        }
    // }else if (!req.params.id){
    //     return res.status(404).json(err)
    } else {
        return res.status(403).json("cannot delete others account")
    }
});

// router.get("/:id", async (req, res) => {
//     // HTTP post request
//     try{
//         const AI = await AIaccount.findById(req.params.id);
//         if (AI.IsPrivate == true){
//             return res.status(200).json(AI.AIname) 
//         } else {
//         const { password, email, updatedAt, ...others} = AIaccount._doc;
//         //Destructuring assignment is a special syntax that allows us to “unpack” arrays or objects into a bunch of variables, as sometimes that’s more convenient.
//         // using the concept and it will prevent password, email, and the time it is updated to be exposed to the third party
//             return res.status(200).json(others)
//     }         
//     } catch(err) {
//         return res.status(500).json(err)
//     }

// });

router.get("/all", async (req, res) => {
    // HTTP post request
        try{
            const account = await AIaccount.find({ IsPrivate: false})
            return res.status(200).json(account)         
        } catch(err) {
            return res.status(500).json(err)
        }
});

router.get("/", async (req, res) => {
    // HTTP post request    
    const AIname = req.query.AIname;
    try{
        const AI = await AIaccount.findOne({ AIname: AIname })
        if (AI.IsPrivate == true){
            const { password, updatedAt, BelongTo, Desc, ...others} = AI._doc;
            res.status(200).json(AI) 
        } else {
        const { password, email, updatedAt, ...others} = AI._doc;
        res.status(200).json(AI)}         
    } catch(err) {
        return res.status(500).json(err)
    }
});

router.get("/:id/parent", async (req, res) => {
    // HTTP post request
        try{
            const accounts = await Authorized.find({AIId: req.params.id})
            return res.status(200).json(accounts)         
        } catch(err) {
            return res.status(500).json(err)
        }
});



// router.put("/:id/follow", async (req, res) => {
//     if (req.body.userId === req.params.id) {
//         try{
//             // console.log("1");
//             const user = await User.findById(req.body.userId);
//             const team = await Team.findById(req.body.teamId);
//             // find user and team data from team database and 
//             // console.log("2");
//             if (!user.BelongTo.includes(req.body.teamId) && !team.followers.includes(req.body.userId)){
//                 await team.updateOne({
//                     $push: {
//                         followers: req.body.userId,
//                     }
//                 });
//                 // console.log("3");
//                 await user.updateOne({
//                     $push: {
//                         BelongTo: req.body.teamId,
//                     }
//                 });
//                 // console.log("4");
//                 return res.status(200).json("waaay, you followed that team yeah?") 
//             }else{
//                 return res.status(403).json("you have already followed the account")
//             }       
//         }catch(err){
//             res.status(500).json(err);
//         }
//     }else{
//         return res.status(500).json("you cannot follow yourself.")
//     }
// })

    
        

module.exports =  router;