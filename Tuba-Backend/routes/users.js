const router = require("express").Router();
const Key = require("../models/Key");
const User = require("../models/User");
const Team = require("../models/Team");
const nodemailer = require("nodemailer");
const bcrypt = require("bcrypt")
const { OpenAIApi, Configuration, default: OpenAI, } = require("openai");
// const  {XorAscii, ValueToChar, decription, NaturalXOR} = require("./auth");



// router.post("/verification",  async(req, res) => {
//     try{
//         let {userId, otp} = req.body;
//         if (!userId || otp){
//             throw Error("Empty otp")
//         }else(err){

//         }
//     }
// })

function XorAscii(str, len){
        const key_index = []
        // store the values used in key
        const pass = []
        // store password as an ASCII code
        
        for (let i = 0; i < len; i++) {
            // while the index is less than the length it will convert all of the character into ascii code
            ASCII = str.codePointAt(i);
            // push them into the stack
            pass.push(ASCII);
            // moy not be needed
        }

        while (key_index.length < pass.length){
            const key_additional = Math.floor(Math.random() * 128);
            // generate a key by making list of random numbers from 1 to 127
            key_index.push(key_additional)
        }
    
        return key_index;
        // return key_index, decrypter;
    }

function NaturalXOR(str){
    XORActual = []    
        for (let i = 0; i < str.length; i++) {
            // while the index is less than the length it will convert all of the character into ascii code
            ASCII = str.codePointAt(i);
            // push them into the stack
            XORActual.push(ASCII);
        }
    return XORActual
}

function decription(arr, arr2){
    {
        const decrypter = []
        for(let z=0; z < arr.length; z++ ) {
            let value = arr[z]^arr2[z];
            // passing the key and random numbers into XOR gate(Vernam cipher)
            decrypter.push(value)
            // store the list of number generated by the VOR gate
        }
        return decrypter
    }  
}

function ValueToChar(List){
    const hashed_pass = []
    for(let z=0; z < List.length; z++ ) {
        
        if(List[z] < 33){
            List[z] = List[z] + 33
         }
        // value less than 33 cannot be converted into ascii character so has to be greater than 32
        hashed_pass.push(List[z])
        // push the password into the stack
    }
    let stored_password = ""
 
    for (let l=0; l<hashed_pass.length; l++){
        stored_password += String.fromCharCode(hashed_pass[l])
        // convert them into String
    }
    return stored_password;
}

// CRUD concepts
// user update
router.put("/password/:id", async (req, res) => {
    // HTTP post request
    if (req.body.userId === req.params.id ) {
        // only if userID is same as theie userID.
        try{
            // console.log(test.XorAscii(req.body.password))
            const keycode = XorAscii(req.body.password, (req.body.password).length)
            // console.log(keycode);
            // console.log( ValueToChar(decription(keycode,NaturalXOR(req.body.password))))
            // console.log(decription(keycode,NaturalXOR(req.body.password)))
            // console.log(ValueToChar(decription(keycode,NaturalXOR(req.body.password))))
            const user = await User.findByIdAndUpdate(req.params.id, {
                    password: ValueToChar(decription(keycode, NaturalXOR(req.body.password))),
                 // set command allows user to change any values in their database
            });
        //     const { password, ...other } = user._doc;
        //     const auser = await User.findByIdAndUpdate(req.params.id, {
        //         other: req.body,
        //      // set command allows user to change any values in their database
        // });

            const key = await Key.findOneAndUpdate({userId: req.body.userId}, {
                key_code: keycode,
                second: decription(keycode, NaturalXOR(req.body.password)),
            }); 

            return res.status(200).json("Your password is updated")               
                  
        } catch(err) {
            return res.status(500).json(err)
        }
    } else {
        return res.status(403).json("cannot change others")
    }
});

router.put("/:id", async (req, res) => {
    // HTTP post request
    if (req.body.userId === req.params.id ) {
        // only if userID is same as theie userID.
        try{
            if (!req.body.password){
                if (req.body.Desc){
                    const openai = new OpenAI({
                        apiKey: process.env.OpenAI,
                    });
                    console.log(openai)
                    const embeddingResponse = await openai.embeddings.create({
                        model: 'text-embedding-ada-002',
                        input: req.body.Desc
                    })
                    const one_post_vector_data = embeddingResponse.data[0].embedding;
                    const user = await User.findByIdAndUpdate(req.params.id, {
                            username: req.body.username,
                            Desc: req.body.Desc,
                            ProfilePicture: req.body.ProfilePicture,
                            IsPrivate: req.body.IsPrivate,
                            IsPicturePrivate: req.body.IsPicturePrivate,
                            email: req.body.email,    
                            tags: one_post_vector_data,            
                        // apart from password user can change any user information as they want
                    });
                }else {
                    const user = await User.findByIdAndUpdate(req.params.id, {
                        username: req.body.username,
                        ProfilePicture: req.body.ProfilePicture,
                        IsPrivate: req.body.IsPrivate,
                        IsPicturePrivate: req.body.IsPicturePrivate,
                        email: req.body.email,  
                    // apart from password user can change any user information as they want
                    });
                }
                return res.status(200).json("your account is updated. enjoy!") 
            } else {
                return res.status(500).json("you cannot change your password in this section sorry.")
            }             
                  
        } catch(err) {
            return res.status(500).json(err)
        }
    } else {
        return res.status(403).json("cannot change others")
    }
});


router.delete("/:id", async (req, res) => {
    // HTTP post request
    
        try{
            const user = await User.findByIdAndDelete(req.params.id);
            const key = await Key.findOneAndDelete({userId: req.params.id});
            // when they are deleted, keys will also be deleted.
            res.status(200).json("your account has been deleted.")           
        } catch(err) {
            return res.status(500).json(err)
        }
    // }else if (!req.params.id){
    //     return res.status(404).json(err)
});

router.get("/:id", async (req, res) => {
    // HTTP post request    
    try{
        const user = await User.findById(req.params.id);
        console.log(user)
        if (user.IsPrivate == true){
            const { password, email, updatedAt, BelongTo, Desc, ...others} = user._doc;
            res.status(200).json(others) 
        } else {
        const { password, email, updatedAt, ...others} = user._doc;
        //Destructuring assignment is a special syntax that allows us to “unpack” arrays or objects into a bunch of variables, as sometimes that’s more convenient.
        // using the concept and it will prevent password, email, and the time it is updated to be exposed to the third party
        res.status(200).json(others)}         
    } catch(err) {
        return res.status(500).json(err)
    }
});
router.get("/all/all", async (req, res) => {
    // HTTP post request
        try{
            const account = await User.find({ IsPrivate: false })
            return res.status(200).json(account)         
        } catch(err) {
            return res.status(500).json(err)
        }
});
router.get("/email/email",  async (req, res) => {
    // HTTP post request
        try{
            console.log(req.query)
            console.log("given that we have an email: ", req.query.email)
            const account = await User.findOne({ email: req.query.email })
            if (!account){
                return res.status(404).json("no account exist")
            } else{
                return res.status(200).json(account)  
            }       
        } catch(err) {
            return res.status(500).json(err)
        }
})
router.get("/", async (req, res) => {
    // HTTP post request 
    if (!req.body.username){        
        const userId = req.query.userId;
        const username = req.query.username;
        try{
            const user = userId ? await User.findById(userId) : await User.findOne({ username: username })
            if (user.IsPrivate == true){
                const { password, email, updatedAt, BelongTo, Desc, ...others} = user._doc;
                res.status(200).json(others) 
            } else {
            const { password, email, updatedAt, ...others} = user._doc;
            res.status(200).json(others)}         
        } catch(err) {
            return res.status(500).json(err)
        }
    }else{
        const username = req.body.username;
        const user = await User.findOne({ username: username })
        try{
            if (!user){
                return res.status(404).json("there is no such user")
            } else{
                if (user.IsPrivate == true){
                    const { password, email, updatedAt, BelongTo, Desc, ...others} = user._doc;
                    res.status(200).json(others) 
                } else {
                const { password, email, updatedAt, ...others} = user._doc;
                res.status(200).json(others)}
            }}catch(err){
                return res.status(500).json(err)
            }
    }
});

router.put("/:id/join", async (req, res) => {
    try{
        // console.log("1");
        const user = await User.findById(req.body.userId);
        const team = await Team.findById(req.params.id);
        // find user and team data from team database and 
        // console.log("2");
        if (!user.BelongTo.includes(req.params.id) && !team.followers.includes(req.body.userId)){
            await team.updateOne({
                $push: {
                    followers: req.body.userId,
                }
            });
            // console.log("3");
            await user.updateOne({
                $push: {
                    BelongTo: req.params.id,
                }
            });
            // console.log("4");
            return res.status(200).json("waaay, you followed that team yeah?") 
        }else{
            return res.status(403).json("you have already followed the account")
        }       
    }catch(err){
        res.status(500).json(err);
    }
    
})

module.exports =  router;


