const router = require("express").Router();
// const { password } = require("pg/lib/defaults");
const User = require("../models/User");
const Key = require("../models/Key");
const nodemailer = require("nodemailer");
const bcrypt = require("bcrypt");
const UserOTP = require("../models/UserOTP");
// this code allow to query information about request


function XorAscii(str, len){
    const key_index = []
    // store the values used in key
    const pass = []
    // store password as an ASCII code
    
    for (let i = 0; i < len; i++) {
        // while the index is less than the length it will convert all of the character into ascii code
        ASCII = str.codePointAt(i);
        // push them into the stack
        pass.push(ASCII);
        // moy not be needed
    }

    while (key_index.length < pass.length){
        const key_additional = Math.floor(Math.random() * 128);
        // generate a key by making list of random numbers from 1 to 127
        key_index.push(key_additional)
    }
 
    return key_index;
    // return key_index, decrypter;
}

function NaturalXOR(str){
    XORActual = []    
        for (let i = 0; i < str.length; i++) {
            // while the index is less than the length it will convert all of the character into ascii code
            ASCII = str.codePointAt(i);
            // push them into the stack
            XORActual.push(ASCII);
        }
    return XORActual
}

function decription(arr, arr2){
    {
        const decrypter = []
        for(let z=0; z < arr.length; z++ ) {
            let value = arr[z]^arr2[z];
            // passing the key and random numbers into XOR gate(Vernam cipher)
            decrypter.push(value)
            // store the list of number generated by the VOR gate
        }
        return decrypter
    }  
}

function ValueToChar(List){
    const hashed_pass = []
    for(let z=0; z < List.length; z++ ) {
        
        if(List[z] < 33){
            List[z] = List[z] + 33
         }
        // value less than 33 cannot be converted into ascii character so has to be greater than 32
        hashed_pass.push(List[z])
        // push the password into the stack
    }
    let stored_password = ""
 
    for (let l=0; l<hashed_pass.length; l++){
        stored_password += String.fromCharCode(hashed_pass[l])
        // convert them into String
    }
    return stored_password;
}

const randomnised_number = async({ _id, email }, res) => {
    try{
        const otp = `${Math.floor(1000 + Math.random()*9000)}`
        const mailOptions = {
            from: process.env.AUTH_EMAIL,
            to: email,
            subject: "verify your email",
            html: `<p> Enter<b>${otp}</b></p>`
            
        }
        const saltRound = 10;
        hashedOTP = await bcrypt.hash(otp, saltRound);
        const newOTP = new UserOTP ({
            userId: _id,
            otp: hashedOTP,
        });
        await newOTP.save()
        await transporter.sendMail(mailOptions);
        return res.status(200).json("email sent")

    }catch(err){
        console.log(err)
    }
}
let transporter = nodemailer.createTransport({
    service: 'gmail',
    auth: {
        user: process.env.AUTH_EMAIL,
        pass: process.env.AUTH_PASS,
    }
}) 

router.post("/register", async (req, res) => {
// HTTP post request is used 
    try{
        const keycode = XorAscii(req.body.password, (req.body.password).length) 
        // const decrypter = decription(keycode)
        // const Displayed = ValueToChar(decrypter)
        // console.log(decrypter);

        const newUser = await new User({
            username: req.body.username,
            email: req.body.email,
            password: ValueToChar(decription(keycode,NaturalXOR(req.body.password))),
        });
        const user = await newUser.save()


        const newKey = new Key({
            userId: user.id,
            key_code: keycode,
            second: decription(keycode,NaturalXOR(req.body.password)),
        });
        // // const newKey = await new Key({
        // //     key_code: ({user.key_code}),
        // // })
        const key = await newKey.save();
        // const theUser = await User.findOneAndUpdate( user.email == req.body.email,{
        //     password: ValueToChar(key_code),
        // })
        
        // const neo_User = await theUser.save();
        return res.status(200).json(user)
    } catch(err) {
        return res.status(500).json(err)
    }    
});


router.post("/login", async (req, res) => {
// HTTP post request
    try{
        const user = await User.findOne({ email: req.body.email });
        if (!user){return res.status(404).send("cannot find email.")}
        else{
        // if written emaiil doesnot exist. 404 indicate to "NOT Found"
        const key = await Key.findOne({ userId: user._id })  
        // taking userId as an input... improvement is needed.      

        const ValidPassword = ValueToChar(decription(key.key_code,NaturalXOR(req.body.password))) === user.password;
        if (!ValidPassword){ return res.status(400).send("invalid password. ")}
        // if ValidPassword is not equal to the password request. 400 indicate to Bad request"
        else{
        
        return res.status(200).json(user)}}
    } catch(err) {
        return res.status(500).json(err)
    }    
});

module.exports =  router;
// exports = { ValueToChar, XorAscii, decription, NaturalXOR };

// exports.ValueToChar = ValueToChar
// exports.decription = decription
// exports.NaturalXOR = NaturalXOR
// exports.XorAscii = XorAscii

// module.exports = {XorAscii, ValueToChar, decription, NaturalXOR}